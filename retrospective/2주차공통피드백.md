# 2주 차 공통

---

# 📌 좋은 프로그래머란?

- 개발자에게 필요한 6가지 역량 from 프로그래머스
    - 개발력: 설계, 클린 코드, 버그가 없는 코드, 라이브러리 활용, 리팩토링, 빠른 코드 파악, CS, 디버깅
    - 기획력: 기획에 대한 이해도가 높음, 즉 현재 문제 상황을 인지하고 어떻게 풀어낼지, 기획자가 모든 상황에 대한 처리를 명시해 주는 것은 사실상 불가능(명시되지 않은 요구사항의 처리)
    - 협업능력: 함께 성장(공유), 개방성(다른 사람의 의견(코드) 듣기, 보기), 적극성, 설득력(설명, 자신의 판단 근거)
    - 학습능력: 어떻게 동작하는지 깊게 살펴보는 탐구성향(디버깅), 새로운 시도에 대한 적극성(한 가지 패러다임, 기술 등을 맹신하고 집착하지 않는다), 학습 습관(학습 테스트, 정리 to 공유, 토이 프로젝트), 지속적인 개선, 정보 탐색(원하는 정보를 얼마나 빨리 찾을지, 효과적인 구글링, 학습 내용 정리)
    - 성향: 근원적 문제해결, 끈기, 성실성, 진실성(내 생각과 의견을 있는 그대로 논리적으로 설명하고 타인의 생각과 의견을 듣고 간극을 좁혀나간다), 결과 공유를 두려워하지 않음(피드백을 받기 위해)
    - 도메인지식: 자신이 일하는(현재 주어진 미션) 영역의 도메인 지식
- 의도를 가지고 코딩한다
- 항상 의심(의문 제기)
- 원활한 커뮤니케이션: 커뮤니케이션을 잘 하려면?
    - 짧은 글을 잘 써야 한다 -> 글을 잘 쓰면 말하기 능력도 올라감
    - 논리적인 근거를 들어가며 비개발자도 이해할 수 있는 쉬운 언어로 대체
    - 커뮤니케이션의 목적과 목표를 명확하게 설정, 용어 통일
    - 지엽적인 내용을 걸러내고 본질을 파악하기
- 관리 능력
    - 일정: 자신의 역량이 어느정도인지 파악하고, 주어진 업무(미션)를 기간 내에 달성할 수 있을지 파악
    - 관계: 솔직함

# 📌 회고: 메타인지를 위한 최고의 도구 중 하나

- 좋은 회고란?
- 회고를 하면서 어떤 것을 배우고, 깨닫고, 느꼈는지 → 이 생각을 어떻게 행동으로 바꿀 것인지
    - 먼저 쉬운 단계부터 시작. 미션의 난이도가 올라가는 상황에서 바로 적용하는데 어려움이 따를 수 있음
    - 이전 미션에서 별도의 브랜치를 생성해 진행

# 📌 README

- `README` 에는 기능 목록 말고 어떤 내용들이 담겨야 하나?
    - 나를 읽어줘 → 프로젝트를 읽어줘 → 이 프로젝트가 무엇을 목적으로, 어떻게 사용하는지 적었으니 읽어줘
        - 내가 몇달 뒤에 읽어도 이해하기 쉽게
    - 프로젝트의 `첫인상`을 결정하는 중요한 요소
    - 스프링의 README
        - 상단에 어떤 프로젝트인지(목적) 짧고 간결하게 나옴, 프로젝트를 한, 두 문장으로 명확하게 설명(피칭)
        - 단계별 설치 가이드, 핵심 기능들의 간단한 코드 예제
        - 목차로 명확한 정보 계층을 나눔
    - 피칭: 한, 두 문장으로 짧게 어떤 프로젝트인지 설명
    - [ 피칭 + 핵심 도메인(1급 개념) ]: 어떤 프로젝트인지
    - [기능 목록 + 명시되지 않은 요구사항 처리 방법과 판단 근거 + docs/ 파일 링크(docs/ 폴더의 문서가 어떤 내용인지 대략적인 설명 추가)]: 주요 기능이 무엇인지
- 기능 목록의 재검토
    - 기능 목록에 들어가지 않으면 좋은 내용: 클래스 설계와 구현, 메서드 설계와 구현 같은 상세한 내용
        - 왜? 언제든 변경이 가능한 요소임
    - 그렇다면 변경이 일어날 가능성이 낮은 요소는? 개념, 개념이 클래스가 아닌가요? 클래스는 개념을 객체로 표현하기 위한 방법 중 하나, 현재 미션에서 중간에 요구사항이 변경될 확률은 매우 낮아 설정한 핵심 개념들이 변경될 확률이 낮음
    - 기능 목록 == 개념 간 협력에 필요한 행동(요청, 응답)들의 목록
    - 단, 기능 목록도 변할 수 있다. 개념은 구현 시작 전 뼈대를 잡기 위해 설정. 실제 구현에 들어가면 개념이라 생각했던 것이 개념이 아니고, 상태와 행동이라 생각했던 것들이 개념이 될 수 있음 → 이를 반영

# 📌 상수는 언제 사용할까?

- 상수를 `static final`로 정의하는 이유
    - 앞의 접근 제어자는 명시되지 않음: 노출의 여부, 상수를 외부로 노출해도 되는가? 안되는가?
- 상수는 의미 있는 이름을 부여하고, 해당 값이 어떤 역할을 하는지 명확히 드러낸다 → 문자열과 숫자 값 그 자체로 의미 있고, 어떤 역할인지 드러난다면 굳이 상수를 쓸 필요가 있나?
- 도메인 규칙을 공개된 상수로 정할 필요가 있을까
- enum: 상수를 사용해야 겠다는 판단이 든 경우, 모두 enum로 관리해야 할까? enum이 필요한 이유는?
    - 인텔리제이에서 new → class를 선택하면 뜨는 목록 중 enum이 존재한다
    - class는 객체를 코드에 담는 방법 중 하나, 해당 상수를 모아 enum을 만들었을 때, 객체로 바라보면 유의미한 역할과 책임을 갖고 협력에 참여하고 있나?
    - enum은 특이한 클래스다. 상수 처럼 사용하지만 static 영역이 아닌 인스턴스가 저장되는 힙(heap) 영역에 존재한다 → enum도 객체의 관점으로 바라봐야 하는 근거
    - enum이 역할(책임)을 갖고 협력에 참여하지만, 값이 고정되어 있다 → 고유한 값 객체? 싱글톤으로 생성되어 main()과 같은 생명주기를 갖음
    - enum은 java.lang.Enum을 상속 받고, java.lang.Enum은 Object를 상속 받음. 하지만 clone, finalize, equals, hashCode 메서드를 오버라이딩 하지 못하게 final 로 막아놓음. 왜?
    - 고유한 값 객체이기 때문에 오버라이딩을 통해 바꾸면 고유성이 없어짐
    - enum이 주는 장점: 고유한 값들을 의미있게 묶어서 활용, 단순히 상수 값을 넘어서 상수 메소드로서도 이용이 가능, 추상 메서드를 정의해 각 상수마다 메서드를 재정의해 사용 가능, 행동을 수행하는 상수로서도 응용 확장이 가능(상수의 상태와 행동를 한 곳에서 관리가 가능)

# 📌 한 메서드가 한 가지 기능만 담당

- 메서드가 길다 == 여러 기능을 한 함수에서 처리하고 있을 가능성이 높다
- indent depth가 깊다 == 여러 기능을 한 함수에서 처리하고 있을 가능성이 높다
- 15 라인이 넘지 않도록 구현 == 의식적인 연습 == 한 메서드가 한 가지 기능만 담당할 수 있게 만드는 훈련을 할 때 필요한 제한 사항
    - 테스트 메서드도 15 라인이 넘지 않도록
    - 프로덕션 코드: 라인 시작점은 메서드 시그니처 라인, 종료점은 `}`
    - 테스트 코드: 라인 시작점은 애노테이션, 종료점은 `}`

# 📌 학습 테스트가 좋은 이유

- 시스템 출력을 통한 확인이 필요 없음
- 시스템 출력을 통한 확인이 필요한 메서드/기능의 경우 별도의 main() 없이 가능
    - 여기에 디버깅을 한다면 브레이크 포인트와 Variables, Evaluate, Watch를 활용해 볼 수 있음
- 디버깅을 함께 사용하면 라이브러리 내부 구조를 파악하기 쉬움
- 테스트 프레임워크에 익숙해짐, 빠른 테스트 작성이 가능해짐(구상한 테스트 시나리오에 맞는 단위 테스트 패턴을 빠르게 생각하고 만들 수 있음)
- 학습 테스트는 단위 테스트, 빠른 피드백을 받으며 작은 단위 테스트에 익숙해질 수 있음
- 테스트의 장점 중 본인이 가장 공감하는 작성 이유