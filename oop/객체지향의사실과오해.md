# 객체 지향의 사실과 오해 정리

> 노션에 정리한 "객체 지향의 사실과 오해"의 전체 내용을 빠르게 정리

# 협력하는 객체들의 공동체

- 객체지향은 현실 세계의 모방이 아닌 새로운 세계의 창조
- **캡슐화**하는 객체의 **자율성**을 설명하는데 효과적이기 때문에 모방이라는 비유를 든다
- 메시지를 주고받으며 공동의 목표를 달성하기 위해 협력하는 객체들의 관계
- 역할, 협력, 책임
  - 책임은 역할의 부분집합, 특정한 역할은 특정한 책임을 암시한다
  - 추상화 & 다형성: 여러 사람이 동일한 역할을 수행할 수 있다, 역할은 대체 가능, 동일한 역할을 서로 다른 방식으로 수행한다
  - 요청은 연쇄적으로 발생한다
- 적절한 객체(개념)에게 적절한 책임을 할당
- 객체는 메시지를 주고 받으며 협력하는 존재
  - 격벽을 넘을 수 있는 객체만이 다른 객체에게 메시지를 보낼 수 있다
- 객체는 충분히 협력적이며 자율적이여야 한다
  - 객체는 요청에 그저 메시지로 응답한다. 어떻게 응답할지는 객체 스스로 판단하고 결정한다
  - 객체는 협력에 참여하지만 스스로의 결정과 판단에 따라 행동한다
- 객체는 상태(state)와 행동(behavior)을 함께 지닌 실체다. 객체의 자율성은 내부와 외부를 명확하게 구분하는 것으로부터 나온다
  - 다른 객체가 무엇을 수행하는지 알 수 있지만, 어떻게 수행하는지에 대해서는 알 수 없다
- 메시지와 메서드의 분리는 협력에 참여하는 객체들 간의 자율성을 증진시킨다. 요청하는 객체는 응답 객체가 메시지를 처리하는 구체적 방법에 관여하지 않는다. 외부 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘(캡슐화)
- 협력하는 객체들의 공동체로 바라본다. 즉, 클래스가 아닌 메시지를 주고받는 객체의 관점으로 바라보자
- 역할, 책임, 협력에 집중하라. 객체를 지향하는 것이지 클래스를 지향하는 것이 아니다

# 이상한 나라의 객체

- 객체를 만드는 것은 지식과 행동을 구조화하는 것
- 행동(메서드)이 상태(데이터, 필드)를 바꿀 수 있다
- 객체(개념)는 상태 변경과 무관하게 유일한 존재로 식별 가능하다. 엘리스(객체)가 커지거나 작아지든 엘리스다
- 객체는 식별 가능해야 한다. 객체는 식별자를 지닌 실체로 상태, 행동을 갖는다
- 상태가 필요한 이유: 상태를 알면 행동의 결과를 쉽게 예측할 수 있다. 객체가 상태를 갖는 이유는 복잡성을 줄이고 인지 과부하를 줄일 수 있기 때문이다
- 단순한 값들은 객체가 될 수 없다.
- 객체의 프로퍼티(property): 객체의 상태를 구성하는 모든 특징, 프로퍼티 자체는 변하지 않는다. 하지만 프로퍼티의 값은 시간의 흐름에 따라 변경되는 동적인 값이다. 엘리스의 키(프로퍼티)는 시간에 따라 크고 작아지지만, 키라는 프로퍼티 자체는 그대로다
- 객체의 행동(메서드): 객체의 상태를 변경할 수 있는 유일한 수단은 객체의 자발적인 행동이다
- 객체의 행동은 두 가지 결과를 만든다. 자신의 상태 변경과 협력하는 다른 객체에 대한 메시지 전송을 통해 다른 객체의 상태 변경을 유발한다
- 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다. 메시지를 통해 다른 객체의 상태 변경을 유발한다해도 정말 상태가 변했는지, 변했다면 어떤 상태로 변했는지 알지 못하고 알 수 없다(캡슐화)
- 상태를 잘 정의된 행동 뒤로 캡슐화하는 것이 자율성을 높이고 협력을 단순하고 유연하게 만든다
- 식별자를 갖는 이유는 가변적인 객체의 동일성 판단을 위해서다. 객체의 상태 값은 가변(계속 변해 )
- 참조 객체(Reference Object), 엔티티(Entity): 식별자를 지닌 전통적인 의미의 객체
- 값 객체(Value Object): 식별자를 가지지 않는 값
- 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 악영향, 객체의 적합성을 결정하는 것은 상태가 아닌 객체의 행동이다
  - 필요한 협력을 생각 -> 협력에 참여하는데 필요한 행동을 생각 -> 행동을 수행할 객체(개념)를 선택
- 소프트웨어의 객체는 능동적이다. 현실 세계의 숫자 야구 게임을 생각하면 숫자가 스스로 랜덤한 숫자를 만들어낼 수 없다. 하지만 소프트웨어 세계의 숫자는 스스로 숫자를 생성하고 바꾼다

# 타입과 추상화

- 연결성(협력도)을 얼마나 직관적으로 표현했나, 현실의 정확성을 버리고 꼭 알아야 하는 사실만 정확하게 표현하고 몰라도 되는 정보는 무시해야 한다. 이것이 **추상화**다
- 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화한다
- 추상화
  - 어떤 양상, 세부 사항, 구조를 명확하기 이해하기 위해 절차나 물체를 의도적으로 생략하거나 감춰 복잡도를 낮추는 방법
  - 일반화(공통점은 취하고 차이점은 버린다), 중요한 부분(목적)을 강조하기 위해 불필요한 세부 사항을 제거한다
  - 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것
- 개념(concept): 공통점(공통 특성)을 기반으로 객체들을 묶기 위한 그릇
  - 엄밀히 그룹화가 아니다. 격벽을 세워 같은 격벽 내의 객체들은 자유롭게 소통하고, 격벽 밖의 객체들은 접근을 허용한 객체만이 격벽을 통과할 수 있다 -> 객체에 대한 제어와 통제권을 갖는다
- 개념을 생각하는 세 가지 관점
  - 심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭
  - 내연(intension): 개념의 완전한 정의, 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인
    - 어떤 문자열(숫자와 문자로 이루어진 문자열)을 나누는 기준, 이 기준을 통해 의미있는 문자로 나눈다(숫자) -> 구분자의 개념(내연)
  - 외연(extension): 개념에 속하는 모든 객체의 집합
    - 이 문자가 구분자가 될 수 있나?
- 객체의 행동, 객체가 협력을 위해 어떤 책임(행동)을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심
  - 어떤 타입에 속하는 객체인지 결정하는 것은 객체의 행동
  - 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다
- 외부에 행동망을 공개하고, 데이터는 행동 뒤로 감춘다
- 타입 == 개념, 공통점을 기반으로 객체들을 묶기 위한(같은 격벽 안에 위치시킴) 틀, 타입은 일반화/특수화 관계를 갖는다
  - 일반적 타입: 특수한 타입이 가진 모든 행동들 중 일부 행동만 갖음
  - 특수한 타입: 일반적인 타입이 가진 모든 행동 + 자신만의 행동

# 역할, 책임, 협력

- 협력이라는 문맥(context)이 객체의 행동 방식을 결정한다, 협력에 초점을 맞춰 설계한다
- 협력은 요청과 응답의 연쇄적인 흐름으로 구성된다. 객체지향은 동일한 목적을 달성하기 위해 협력하는 객체들의 공동체다
- 요청(public 메서드 호출)은 처리할 책임이 무엇인지 암시한다
- 객체의 책임은 무엇을 알고 있는가(knowing), 무엇을 할 수 있는가(doing)로 구성된다
  - 하는 것(doing): 다른 객체의 행동을 시작, 다른 객체의 활동을 제어하고 조절
  - 아는 것(knowing): 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 책임은 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다
- 역할은 책임의 집합이다
- 협력이라는 문맥을 고려하지 않으면 각 객체를 독립적으로 바라보게 된다. 즉, 협력하는 공동체를 만들 수 없다
- 책임을 먼저 생각하고, 책임을 수행할 객체를 선택한다. 이렇게 할당된 책임은 외부에 제공하게 될 행동을 정의하게 된다. 행동이 결정되면 필요한 데이터를 정의할 수 있다
- 올바른 책임을 올바른 객체에게 할당
- TDD는 책임을 수행할 객체 or 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고, 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 테스트 코드의 형태로 작성하는 것이다
- TDD로 협력 안에서 객체의 역할과 책임이 무엇인지 생각한다

# 책임과 메시지

- 책임은 메시지를 수신한 객체가 수행하는 행동이고, 자율적인 객체는 스스로의 의지와 판단에 따라 책임을 수행한다
- 너무 포괄적이고 추상적인 책임은 좋지 않다. 책임이 너무 상세한 것도 문제지만, 의도를 명확하게 표현하지 못할 정도로 추상적인 것 역시 문제다
- 책임은 어떻게가 아니라 무엇을 해야 하는가를 설명한다. 책임을 완수하기 위해 어떻게 해야 하는지 상세하게 요청하면 객체는 자율성을 잃는다
- 메시지
  - `수신자.메시지이름(인자1, 인자2)` -> `모자장수.증언해(어제, 왕국)`
  - 수신자에게 무엇을 해야하는지 알려주는 게 메시지다
  - 즉, 모자장수에게 어제 왕국에서 있었던 일을 증언하라는 책임을 메시지를 통해 알려준다
- 메시지로 객체에게 묻지 말고 시킨다. 어떻게 해야 하는지를 지시하지 말고, 무엇을 해야 하는지를 요청한다
  - 데이터를 묻지 말고, 어떻게 해결할지 묻지 말고. 무엇을 해야 하는지 요청한다(시킨다)

# 객체 지도

- 자주 변경되는 기능이 아니라 안정적인 구조를 기반으로 시스템을 구조화한다
- 안정적인 구조를 따라 역할, 책임, 협력을 구성한다
- 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 마련해 둔다
- 도메인 모델링: 구조는 사용자나 이해관계자들이 도메인(domain)에 대해 생각하는 개념과 개념들 간의 관계로 표현한다
- 유스케이스 모델링: 기능은 사용자의 목표를 만족시키기 위한 책임을 수행하는 시스템의 행위
- 도메인(사용자가 프로그램을 사용하는 대상 분야) + 모델(대상을 단순화해 표현한 것, 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태)
- 도메인 모델: 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태
  - SW가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊에 추상화한것
  - 코드는 도메인 모델의 개념과 관계를 은유해야 한다
- 도메인 모델은 [계좌: 계좌번호, 예금액 존재 -> 이자: 금액, 지급일자]

```java
class Account {
  private final String accountNumber; // 식별자
  private int amount; // 가변
  
  void 이자를_지급받는다() {
    interest.pay(this); // 이자 지급을 Interest에게 요청한다
  }
}

class Interest {
  private int amount;
  private LocalDate paymentDate;
  
  int pay(Account account) { ... }
}
```

# 함께 모으기

객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점

- 개념 관점:  설계는 도메인 내부에 존재하는 개념과 개념들 사이의 관계를 표현한다
- 명세 관점: 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점을 옮긴다
  - SW 안의 스스로 살아 숨쉬는 자율적인 객체들의 책임에 초점
  - 객체가 협력을 위해 무엇을 할 수 있는가에 초점
- 구현 관점: 실제 작업을 수행하는 코드
- 개념 관점(클래스가 은유하는 개념, 도메인) -> 명세 관점(인터페이스) -> 구현 관점(실제 클래스의 속성과 메서드)